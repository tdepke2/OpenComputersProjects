local m,q,s,x,A,M,N,O,S,T,Y,Z,aa,ba,ca,da,ea,fa,ia,ja,ka,la,ma,na,qa,ra,sa,ta,ua,va="out","mnet:d",",",math,"mtuAdjusted","send","*","hostname",table,"port","broadcast",pairs,"modem","[0m","mnet",tonumber,"uptime","random",require,"debugLossyActive","dropTime","broadcastReal","tunnel","sendReal",setmetatable,"retransmitTime","modem_message",", flags=","registerDevice","Route is cached, sending from device "local
D=ia"component"local
K=ia"computer"local
oa=ia"event"local
pa=ia"include"local
h=pa"dlog"local
b,z,P,w,o,_,B,H,v,u={},{},{},{},{},{},{},nil,x.floor(2^32),{}local
U
local
G={}qa(z,{__index=G})b[O]=os.getenv().HOSTNAME
or
K.address():sub(1,8)b[T]=2048
b.route=true
b.routeTime=30
b[ra]=3
b[ka]=12
function
b.registerDevice(r,E)xassert(E==nil
or(E.open
and
E.close
and
E[M]and
E[Y]),"provided proxy for device must implement open(), close(), send(), and broadcast().")u[r]=E
if
E
then
E.open(b[T])elseif
D.type(r)==aa
then
u[r]=D.proxy(r)u[r].open(b[T])elseif
D.type(r)==ma
then
local
W=D.proxy(r)u[r]=qa({open=function()end,close=function()end,[M]=function(ga,F,...)return
W[M](...)end,[Y]=function(ga,...)return
W[M](...)end},{__index=W})end
return
u[r]end
function
b.getDevices()return
u
end
for
r
in
D.list(aa,true)do
b[ua](r)end
for
r
in
D.list(ma,true)do
b[ua](r)end
if
D.isAvailable(aa)then
b[A]=da(K.getDeviceInfo()[D.modem.address].capacity)end
if
D.isAvailable(ma)then
b[A]=x.min(da(K.getDeviceInfo()[D.tunnel.address].capacity),b[A]or
x.huge)end
b[A]=(b[A]or
8192)-150
local
r=10
local
E=0.1
local
W=0.1
local
ga=3
function
b.debugEnableLossy(F)local
function
L(C,a)local
j,f,c={},{},{}return
function(...)local
e=S.pack(...)local
i=(x[fa]()<E)if
f[1]then
i=(f[1]==1)S.remove(f,1)end
if
i
then
h[m](aa,"[31mDropped.[0m")return
true
end
local
l=(x[fa]()<W
and
x.floor(x[fa](1,ga))or
0)if
c[1]then
l=c[1]S.remove(c,1)end
if
l>0
then
h[m](aa,"[31mSwapping packet order with next ",l," packets[0m")j[#j+1]={K[ea]()+20,l,e}else
a(S.unpack(e,1,e.n))end
local
g=1
while
j[g]do
local
n=j[g]n[2]=n[2]-1
if
K[ea]()>n[1]or
n[2]<0
then
if
K[ea]()<n[1]then
a(S.unpack(n[3],1,n[3].n))end
S.remove(j,g)g=g-1
end
g=g+1
end
return
true
end
end
for
C,a
in
Z(u)do
if
F
and
not
a[ja]then
a[na]=a[M]a[M]=L(a,a[na])a[la]=a[Y]a[Y]=L(a,a[la])a[ja]=true
elseif
not
F
and
a[ja]then
a[M]=a[na]a[Y]=a[la]a[ja]=false
end
end
end
local
F
function
b.debugSetSmallMTU(L)if
L
and
not
F
then
F=b[A]b[A]=r
elseif
not
L
and
F
then
b[A]=F
F=nil
end
end
function
b.getStaticRoutes()return
G
end
local
function
L(C,a,j,f,c,e,i)if
z[f]and
u[z[f][1]]then
h[m](q,va,z[f][1]," to ",z[f][2])u[z[f][1]][M](z[f][2],b[T],C,a,j,f,c,e,i)elseif
G[N]and
u[G[N][1]]then
h[m](q,va,G[N][1]," to ",G[N][2])u[G[N][1]][M](G[N][2],b[T],C,a,j,f,c,e,i)else
for
l,g
in
Z(u)do
g[Y](b[T],C,a,j,f,c,e,i)end
end
end
local
function
C(a,j,f,c,e,i)local
l=x[fa]()local
g=K[ea]()if
not
a
then
a=_[f]if
not
a
then
a=x.floor(x[fa](1,v))j="s1"..j
end
a=a%v+1
_[f]=a
end
P[l]=g
if
i
then
w[f..s..a]={g,l,j,c,e}end
h[m](ca,"[32mSending packet ",b[O]," -> ",f:sub(2),":",c," id=",l,", seq=",a,ta,j,", m=",e,ba)if
f:sub(2)==b[O]then
local
n=f..s..a
o[n]={g,j,c,e,da(j:match"f(%d+)")}U=U
or
n
return
l
end
L(l,a,j,f:sub(2),b[O],c,e)return
l
end
function
b.send(a,j,f,c,e)h.checkArgs(a,"string",j,"number",f,"string",c,"boolean",e,"boolean,nil")xassert(not
c
or
a~=N,"broadcast address not allowed for reliable packet transmission.")local
i=c
if
a==b[O]or
a=="localhost"then
a=b[O]c=false
end
a=(c
and"r"or"u")..a
local
l=c
and"r1"or""if#f<=b[A]then
C(nil,l,a,j,f,c)else
local
g=x.ceil(#f/b[A])for
n=1,g
do
C(nil,l..(n~=g
and"f0"or"f"..g),a,j,f:sub((n-1)*b[A]+1,n*b[A]),c)end
end
if
i
then
local
g=a..s.._[a]if
e
and
c
then
while
w[g]do
if
not
w[g][5]then
return
g
end
os.sleep(0.05)end
elseif
e
then
while
o[g]do
if
not
o[g][4]then
return
g
end
os.sleep(0.05)end
else
return
g
end
end
end
local
function
a(j)local
f,c=j:match"(.*),([^,]+)$"return
f,da(c)end
local
function
j(f,c)local
e,i=a(f)if
c
and
not
c[5]then
local
l=c[4]c[4]=nil
return
e:sub(2),c[3],l
end
while
c
and
c[5]==0
do
i=i%v+1
c=o[e..s..i]end
if
c
then
local
l={}for
g=c[5],1,-1
do
local
n=o[e..s..i]h[m](q,"Collecting fragment ",e..s..i)if
not(n
and
n[4])then
return
end
l[g]=n[4]i=(i-2)%v+1
end
for
g=1,c[5]do
i=i%v+1
h[m](q,"Removing ",e..s..i," from cache.")o[e..s..i][4]=nil
end
return
e:sub(2),c[3],S.concat(l)end
end
function
b.receive(f,c)h.checkArgs(f,"number",c,"function,nil")if
H
or
U
then
if
not
H
then
H=U
U=nil
end
local
e,i,l=H,a(H)h[m](q,"Buffered data ready, hostSeq=",e,", type(packet)=",type(o[e]))if
o[e]then
H=i..s..l%v+1
if
not
o[e][4]then
return
end
h[m](q,"Attempting return of buffered packet ",e,", dat=",o[e])return
j(e,o[e])else
H=nil
end
end
local
e,i,l,g,n,X,y,J,V,k,R,ha=oa.pull(f,sa)local
I=K[ea]()for
p,d
in
Z(w)do
if
I>d[1]+b[ka]then
if
d[5]then
h[m](ca,"[33mPacket ",p," timed out, dat=",d,ba)if
c
then
c(p,d[4],d[5])end
end
w[p]=nil
elseif
d[5]and
I>P[d[2]]+b[ra]then
h[m](q,"Retransmitting packet with previous id ",d[2])local
t,Q=a(p)d[2]=C(Q,d[3],t,d[4],d[5])end
end
for
p,d
in
Z(P)do
if
I>d+b[ka]then
P[p]=nil
end
end
for
p,d
in
Z(z)do
if
I>d[3]+b.routeTime
then
h[m](q,"Removing stale routing entry for host ",p)z[p]=nil
end
end
if
e~=sa
or(g~=b[T]and
g~=0)or
P[X]then
return
end
y=x.floor(y)R=x.floor(R)for
p,d
in
Z(o)do
if
I>d[1]+b[ka]then
if
d[4]then
h[m](ca,"[33mDropping receivedPacket ",p,ba)end
o[p]=nil
end
end
h[m](ca,"[36mGot packet ",k," -> ",V,":",R," id=",X,", seq=",y,ta,J,", m=",ha,ba)P[X]=I
if
not(z[k]or
G[N])then
z[k]={i,l,I}end
if
V~=b[O]and
b.route
then
h[m](ca,"[32mRouting packet ",X,ba)L(X,y,J,V,k,R,ha)end
if
V==b[O]or
V==N
then
local
p=J:find"[ra]1"k=(p
and"r"or"u")..k
local
d=k..s..y
if
J=="a1"then
if
w[d]then
while
w[d]and
w[d][5]do
h[m](q,"Marking ",d," as acknowledged.")w[d][5]=nil
y=(y-2)%v+1
d=k..s..y
end
else
local
t=_[k]or
0
repeat
t=(t-2)%v+1
d=k..s..t
until
not(w[d]and
w[d][5])d=k..s..t%v+1
h[m](q,"Found unexpected ack, beforeFirstSequence is ",t,", first hostSeq is ",d)local
Q=w[d]if
t~=y
and
Q
and
not
Q[3]:find"s1"then
h[m](q,"Setting syn flag for hostSeq.")Q[3]=Q[3].."s1"end
end
return
end
local
t
if
not
o[d]or
o[d][4]then
t={I,J,R,ha,da(J:match"f(%d+)")}o[d]=t
if
not
p
then
h[m](q,"Ignored ordering, passing packet through.")elseif
J:find"s1"or
B[k]and
B[k]%v+1==y
then
if
J:find"s1"then
h[m](q,"Begin new connection to ",k:sub(2))else
h[m](q,"Packet arrived in expected order.")end
B[k]=y
while
o[k..s..B[k]%v+1]do
B[k]=B[k]%v+1
h[m](q,"Buffered packet ready, bumped last sequence to ",B[k])H=H
or
k..s..B[k]end
else
h[m](q,"Packet arrived in unexpected order (last sequence was ",B[k],")")t=nil
end
else
h[m](q,"Already processed this sequence, ignoring.")end
if
p
then
C(B[k]or
0,"a1",k,R)end
return
j(d,t)end
end
return
b